<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Triangular Decomposition of a Square Matrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for lu {Matrix}"><tr><td>lu {Matrix}</td><td align="right">R Documentation</td></tr></table>
<h2>Triangular Decomposition of a Square Matrix</h2>


<h3>Description</h3>

<p>
Computes triangular decompositions of square matrices.
</p>


<h3>Usage</h3>

<pre>
lu(x, ...)
## S4 method for signature 'dgeMatrix':
lu(x, warnSing = TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
a matrix of square dimension.  No missing values or IEEE
special values are allowed.</td></tr>
<tr valign="top"><td><code>warnSing</code></td>
<td>
(when <code>x</code> is a
<code>"<a href="denseMatrix-class.html">denseMatrix</a>"</code>) logical specifying if a <code><a href="../../base/html/warning.html">warning</a></code>
should be signalled when <code>x</code> is singular.</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
further arguments passed to or from other methods.</td></tr>
</table>

<h3>Details</h3>

<p>
<code>lu()</code> is a generic function with special methods for different types
of matrices.  Use <code><a href="../../methods/html/showMethods.html">showMethods</a>("lu")</code> to list all the methods
for the <code><a href="lu.html">lu</a></code> generic.
</p>
<p>
The method for class <code><a href="dgeMatrix-class.html">dgeMatrix</a></code> (and all dense
matrices) is based on LAPACK's <code>"dgetrf"</code> subroutine.  It returns
a decomposition also for singular matrices.
</p>
<p>
The method for class <code><a href="dgCMatrix-class.html">dgCMatrix</a></code> (and all sparse
matrices) is based on functions from the CSparse library.  It signals
an error when the decomposition algorithm fails, as when <code>x</code> is
(too close to) singular.
</p>


<h3>Value</h3>

<p>
An object of class <code>"LU"</code>, i.e., <code>"<a href="LU-class.html">denseLU</a>"</code>
or <code>"sparseLU"</code>, see <code><a href="sparseLU-class.html">sparseLU</a></code>; this is
a representation of a triangular decomposition of <code>x</code>.</p>

<h3>References</h3>

<p>
Golub, G., and Van Loan, C. F. (1989).
<EM>Matrix Computations,</EM>
2nd edition, Johns Hopkins, Baltimore.
</p>
<p>
Tim Davis (2005)
<a href="http://www.cise.ufl.edu/research/sparse/CSparse/">http://www.cise.ufl.edu/research/sparse/CSparse/</a>
</p>
<p>
Timothy A. Davis (2006)
<EM>Direct Methods for Sparse Linear Systems</EM>, SIAM Series
&ldquo;Fundamentals of Algorithms&rdquo;.
</p>


<h3>See Also</h3>

<p>
Class definitions <code><a href="LU-class.html">LU</a></code> and <code><a href="sparseLU-class.html">sparseLU</a></code>
and function <code><a href="expand.html">expand</a></code>;
<code><a href="qr-methods.html">qr</a></code>, <code><a href="chol.html">chol</a></code>.
</p>


<h3>Examples</h3>

<pre>

##--- Dense  -------------------------
x &lt;- Matrix(rnorm(9), 3, 3)
lu(x)

##--- Sparse ------------------------

pm &lt;- as(readMM(system.file("external/pores_1.mtx",
                            package = "Matrix")),
         "CsparseMatrix")
str(pmLU &lt;- lu(pm))             # p is a 0-based permutation of the rows
                                # q is a 0-based permutation of the columns
## permute rows and columns of original matrix
ppm &lt;- pm[pmLU@p + 1L, pmLU@q + 1L]
pLU &lt;- pmLU@L %*% pmLU@U
## equal up to "rounding"
ppm[1:14, 1:5]
pLU[1:14, 1:5]  # product can have extra zeros
## "prove" consistency (up to rounding):
i0 &lt;- ppm != pLU &amp; ppm == 0
iN &lt;- ppm != pLU &amp; ppm != 0
stopifnot(all(abs((ppm - pLU)[i0]) &lt; 1e-7), # absolute error for true 0
          all(abs((ppm - pLU)[iN]/ppm[iN]) &lt; 1e-9)) # relative error
</pre>



<hr><div align="center">[Package <em>Matrix</em> version 0.999375-30 <a href="00Index.html">Index</a>]</div>

</body></html>
