\HeaderA{sum.exact, cumsum.exact \& runsum.exact}{Basic Sum Operations without Round-off Errors}{sum.exact, cumsum.exact .Ramp. runsum.exact}
\aliasA{cumsum.exact}{sum.exact, cumsum.exact \& runsum.exact}{cumsum.exact}
\aliasA{runsum.exact}{sum.exact, cumsum.exact \& runsum.exact}{runsum.exact}
\aliasA{sum.exact}{sum.exact, cumsum.exact \& runsum.exact}{sum.exact}
\keyword{ts}{sum.exact, cumsum.exact \& runsum.exact}
\keyword{smooth}{sum.exact, cumsum.exact \& runsum.exact}
\keyword{array}{sum.exact, cumsum.exact \& runsum.exact}
\keyword{utilities}{sum.exact, cumsum.exact \& runsum.exact}
\begin{Description}\relax
Functions for performing basic sum operations without round-off errors
\end{Description}
\begin{Usage}
\begin{verbatim}
  sum.exact(..., na.rm = FALSE)
  cumsum.exact(x)
  runsum.exact(x,k)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] numeric vector
\item[\code{...}] numeric vector(s), numbers or other objects to be summed
\item[\code{na.rm}] logical. Should missing values be removed?
\item[\code{k}] width of moving window; must be an odd integer between one and n 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
All three functions use full precision summation using multiple doubles for 
intermediate values. The sum of numbers x \& y is a=x+y with error term 
b=error(a+b). That way a+b is equal exactly x+y, so sum of 2 numbers is stored
as 2 or fewer values, which when added would under-flow. By extension sum of n 
numbers is calculated with intermediate results stored as array of numbers 
that can not be added without introducing an error. Only final result is 
converted to a single number
\end{Details}
\begin{Value}
Function \code{sum.exact} returns single number. Function \code{cumsum.exact} 
returns vector of the same length as \code{x}. Function \code{runsum.exact} 
returns vector of length \code{length(x)-k} and attribute "count" containing
number of finite (as in \code{\LinkA{is.finite}{is.finite}}) elements in each window.
\end{Value}
\begin{Author}\relax
Jarek Tuszynski (SAIC) \email{jaroslaw.w.tuszynski@saic.com} based on
code by Vadim Ogranovich, which is based on algorithms described in 
references, pointed out by Gabor Grothendieck.
\end{Author}
\begin{References}\relax
Round-off error correction is based on:
Shewchuk, Jonathan, \emph{Adaptive Precision Floating-Point Arithmetic and  
Fast Robust Geometric Predicates},  
\url{http://www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps}
and its implementation found at:
\url{http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/393090} 

McCullough, D.B., (1998) \emph{Assessing the Reliability of Statistical 
Software, Part I}, The American Statistician, Vol. 52 No 4, 
\url{http://www.amstat.org/publications/tas/mccull-1.pdf}

McCullough, D.B., (1999) \emph{Assessing the Reliability of Statistical 
Software, Part II}, The American Statistician, Vol. 53 No 2
\url{http://www.amstat.org/publications/tas/mccull.pdf}

NIST Statistical Reference Datasets (StRD) website 
\url{http://www.nist.gov/itl/div898/strd}
\end{References}
\begin{SeeAlso}\relax
\Itemize{       
\item \code{\LinkA{sum}{sum}} is faster but not error-save version of 
\code{sum.exact}
\item \code{\LinkA{cumsum}{cumsum}} is equivalent to \code{cumsum.exact}
\item \code{\LinkA{runmean}{runmean}(x,k,endrule="trim")} is similar to 
\code{runsum.exact}.
}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
  x = c(1, 1e20, 1e40, -1e40, -1e20, -1)
  a = sum(x);          print(a)
  b = sum.exact(x);    print(b)
  stopifnot(b==0)
  a = cumsum(x);       print(a)
  b = cumsum.exact(x); print(b)
  stopifnot(b[6]==0)
\end{ExampleCode}
\end{Examples}

